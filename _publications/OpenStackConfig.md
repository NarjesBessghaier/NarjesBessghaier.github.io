---
title: "What Constitutes the Deployment and Run-time Configuration System? An Empirical Study on OpenStack Projects"
collection: publications
date: July 2023
venue: ACM Transactions on Software Engineering and Methodology
paperurl: 'http://NarjesBessghaier.github.io/files/AICCSA-2017.pdf'
citation: 'Bessghaier, N., Sayagh, M., Ouni, A., & Mkaouer, M. W. (2023). What Constitutes the Deployment and Run-time Configuration System? An Empirical Study on OpenStack Projects. ACM Transactions on Software Engineering and Methodology.'
---
Modern software systems are designed to be deployed in different configured environments (e.g., permissions, virtual resources, network connections), and adapted at run-time to different situations (e.g., memory limits, enabling/disabling features, database credentials). Such a configuration during the deployment and run-time of a software system is implemented via a set of configuration files, which together constitute what we refer to as a “configuration system”. Recent research efforts investigated the evolution and maintenance of configuration files. However, they merely focused on a limited part of the configuration system (e.g., specific infrastructure configuration files or Dockerfiles), and their results do not generalize to the whole configuration system. To cope with such a limitation, we aim by this paper to better capture and understand what files constitute a configuration system. To do so, we leverage an open Card Sort technique to qualitatively study 1,756 configuration files from OpenStack, a large and widely studied open-source software ecosystem. Our investigation reveals the existence of nine types of configuration files, which cover the creation of the infrastructure on top of which OpenStack will be deployed, along with other types of configuration files used to customize OpenStack after its deployment. These configuration files are interconnected while being used at different deployment stages. For instance, we observe specific configuration files used during the deployment stage to create other configuration files that are used in the run-time stage. We also observe that identifying and classifying these types of files is not straightforward, as five out of the nine types can be written in similar programming languages (e.g., python and bash) as regular source code files. We also found that the same file extensions (e.g., Yaml) can be used for different configuration types, making it difficult to identify and classify configuration files. Thus, we first leverage a machine learning model to identify configuration from non-configuration files, which achieved a median AUC of 0.91, a median Brier score of 0.12, a median precision of 0.86, and a median recall of 0.83. Thereafter, we leverage a multi-class classification model to classify configuration files based on the nine configuration types. Our multi-class classification model achieved a median weighted AUC of 0.92, a median Brier score of 0.04, a median weighted precision of 0.84, and a median weighted recall of 0.82. Our analysis also shows that with only 100 labeled configuration and non-configuration files, our model reached a median AUC higher than 0.69. Furthermore, our configuration model requires a minimum of 100 configuration files to reach a median weighted AUC higher than 0.75.
